# Teach Yourself Computer Science
If you‚Äôre a self-taught engineer or bootcamp grad, you owe it to yourself to learn computer science. Thankfully, you can give yourself a world-class CS education without investing years and a small fortune in a degree program. üí∏

There are plenty of resources out there, but some are better than others. You don‚Äôt need yet another ‚Äú200+ Free Online Courses‚Äù listicle. You need answers to these questions:

- **Which subjects should you learn, and why?**
- **What is the best book or video lecture series for each subject?**

This guide is our attempt to definitively answer these questions.

## Outline
Study all nine subjects below, in roughly the presented order, using either the suggested textbook or video lecture series, but ideally both. Aim for **100-200 hours of study** of each topic, then revisit favorites throughout your career. üöÄ

---

| **Subject** | **Why study?** | **Book** | **Videos** |
|------------|---------------|----------|------------|
| **[Programming](Programming/)** | Don‚Äôt be the person who ‚Äúnever quite understood‚Äù something like recursion. | *Structure and Interpretation of Computer Programs* | Brian Harvey‚Äôs Berkeley CS 61A |
| **[Computer Architecture](Computer_Architecture/)** | If you don‚Äôt have a solid mental model of how a computer actually works, all of your higher-level abstractions will be brittle. | *Computer Systems: A Programmer's Perspective* | Berkeley CS 61C |
| **[Algorithms and Data Structures](Algorithms_and_Data-Structures/)** | If you don‚Äôt know how to use ubiquitous data structures like stacks, queues, trees, and graphs, you won‚Äôt be able to solve challenging problems. | *The Algorithm Design Manual* | Steven Skiena‚Äôs lectures |
| **[Math for CS](Math_for_CS/)** | CS is basically a runaway branch of applied math, so learning math will give you a competitive advantage. | *Mathematics for Computer Science* | Tom Leighton‚Äôs MIT 6.042J |
| **[Operating Systems](#Operating_Systems/)** | Most of the code you write is run by an operating system, so you should know how those interact. | *Operating Systems: Three Easy Pieces* | Berkeley CS 162 |
| **[Computer Networking](Computer_Networking/)** | The Internet turned out to be a big deal: understand how it works to unlock its full potential. | *Computer Networking: A Top-Down Approach* | Stanford CS 144 |
| **[Databases](Databases/)** | Data is at the heart of most significant programs, but few understand how database systems actually work. | *Readings in Database Systems* | Joe Hellerstein‚Äôs Berkeley CS 186 |
| **[Languages and Compilers](Languages_and_Compilers/)**  | If you understand how languages and compilers actually work, you‚Äôll write better code and learn new languages more easily. | *Crafting Interpreters* | Alex Aiken‚Äôs course on edX |
| **[Distributed Systems](Distributed_Systems/)** | These days, most systems are distributed systems. | *Designing Data-Intensive Applications* by Martin Kleppmann | MIT 6.824 |

## Still too much?
If the idea of self-studying 9 topics over multiple years feels overwhelming, we suggest you focus on just two books: *Computer Systems: A Programmer's Perspective* and *Designing Data-Intensive Applications*. These two books provide incredibly high return on time invested, particularly for self-taught engineers and bootcamp grads working on networked applications. They may also serve as a "gateway drug" for the other topics and resources listed above.

## Why learn computer science?<a name="Why"></a>
There are 2 types of software engineer: those who understand computer science well enough to do challenging, innovative work, and those who just get by because they‚Äôre familiar with a few high level tools.

<a href="https://twitter.com/jenna/status/838161631662092289">
    <img align="right" width="500" alt="bilotta-tweet" src="https://github.com/user-attachments/assets/d7535b63-7da3-4f31-a129-1f393162f056" />
</a>


Both call themselves software engineers, and both tend to earn similar salaries in their early careers. But Type 1 engineers progress toward more fulfilling and well-remunerated work over time, whether that‚Äôs valuable commercial work or breakthrough open-source projects, technical leadership or high-quality individual contributions.

Type 1 engineers find ways to learn computer science in depth, whether through conventional means or by relentlessly learning throughout their careers. Type 2 engineers typically stay at the surface, learning specific tools and technologies rather than their underlying foundations, only picking up new skills when the winds of technical fashion change.

Currently, the number of people entering the industry is rapidly increasing, while the number of CS grads is relatively static. This oversupply of Type 2 engineers is starting to reduce their employment opportunities and keep them out of the industry‚Äôs more fulfilling work. Whether you‚Äôre striving to become a Type 1 engineer or simply looking for more job security, learning computer science is the only reliable path.

